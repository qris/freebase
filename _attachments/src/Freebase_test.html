<!DOCTYPE html>
<html>
<!--
Based on goog.array.array_test.html from Google Closure
-->
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Freebase Unit Tests - com.qwirx.freebase.Freebase</title>
<script src="../ext/closure-library/closure/goog/base.js"></script>
<script src="calculated_deps.js"></script>
<script src="Freebase.deps.js"></script>
<script src="Freebase.js"></script>
<script>
  goog.require('com.qwirx.freebase.Freebase');
  goog.require('com.qwirx.freebase.TableDocument');
  goog.require('goog.dom.NodeIterator');
  goog.require('goog.testing.PropertyReplacer');
  goog.require('goog.testing.jsunit');
  goog.require('goog.testing.recordFunction');
</script>
</head>
<body>
<script>

// import Freebase, TableDocument and other classes
com.qwirx.freebase.import(this, com.qwirx.freebase);

function testFreebaseConstructor()
{
	var fb = new Freebase();
	assertEquals(fb.constructor, Freebase);
}

function testFreebaseTableId()
{
	var expected = '_design/Foobar';
	assertEquals(Freebase.getTableId('Foobar'), expected);
	assertEquals(Freebase.isTableId(expected), true);
}

function testTableDocumentConstructor()
{
	var name = 'Foobar';
	var cols = [{name: "foo", type: String},
		{name: "bar", type: Number}];
	var td = new TableDocument(name, cols);
	assertEquals(td.constructor, TableDocument);
	assertEquals(td._id, Freebase.getTableId(name));
	assertEquals(td.name, name);
	assertEquals(td.columns, cols);
	
	var all_view = "function(doc) " +
		"{ " +
		"if (doc." + Freebase.TABLE_FIELD + " == '" + td.name + "') { " +
		"emit(doc._id, doc);" +
		"} " +
		"}";
	assertObjectEquals(td.views.all, {map: all_view});
}

function MockFreebase()
{
	this.objectStore = {};
	this.app = {models: {}};
}

goog.inherits(MockFreebase, goog.events.EventTarget);

MockFreebase.prototype.deepCopy =  function(object, opt_stringifier)
{
	return JSON.parse(JSON.stringify(object));
};

MockFreebase.prototype.get = function(documentId, onSuccess, onError)
{
	return this._get(documentId, /* auto instantiate */ true, onSuccess,
		onError);
};

/**
 * findAll calls the "all" view of the named design, (e.g.
 * /_design/Foo/view/all), extracts the objects returned from the results
 * and passes the array of objects (JSON documents) to the onSuccess callback.
 */
MockFreebase.prototype.findAll =  function(designName, onSuccess, onError)
{
	var results = this._get('_design/' + designName + '/_view/all',
		/* auto instantiate */ true,
		function(results)
		{
			var objects = [];
			var l = results.rows.length;
			for (var i = 0; i < l; i++)
			{
				objects[i] = results.rows[i].value;
			}
			onSuccess(objects);
		},
		onError);
};

MockFreebase.prototype.listAll = function(onSuccess, onError)
{
	return this._get('_all_docs', /* auto instantiate */ false,
		onSuccess, onError);
};

MockFreebase.prototype.view = function(designId, viewName, onSuccess, onError)
{
	return this._get(designId + '/_view/' + viewName,
		/* auto instantiate */ false, onSuccess, onError);
};

MockFreebase.prototype.instantiateModel_ = function(object)
{
	var table = object[com.qwirx.freebase.Freebase.TABLE_FIELD];
	var model = this.app.models[table];
	
	if (table && model)
	{
		// call the constructor to build a model object
		// from the database record
		return new model(object);
	}
	else
	{
		return object;
	}
};

MockFreebase.prototype._get = function(uri, autoInstantiate, onSuccess,
	onError)
{
	var selector;
	var viewIndex = uri.indexOf('/_view/');
	
	if (uri.indexOf('_design/') == 0 && viewIndex > 0)
	{
		var designName = uri.substring(0, viewIndex);
		var designDoc = JSON.parse(this.objectStore[designName].json);
		var viewName = uri.substring(viewIndex +
			'/_view/'.length);
		eval("var mapFunction = " +	designDoc.views[viewName].map);
		var emitted = [];
		var self = this;
		
		function emit(key, value)
		{
			var row = {key: key, value: value};
			if (value != null)
			{
				row.id = value._id;
				
				if (autoInstantiate)
				{
					row.value = self.instantiateModel_(value);
				}
			}
			emitted.push(row);
		}
		selector = function(o)
		{
			emitted = [];
			mapFunction(o);
			return emitted;
		}
	}
	else if (uri == "_design/Foobar/_view/all")
	{
		selector = function(o)
		{
			return (o[Freebase.TABLE_FIELD] == 'Foobar') ? [o] : [];
		}
	}
	else if (uri == '_all_docs')
	{
		selector = function(o)
		{
			return [o];
		}
	}
	else if (uri in this.objectStore)
	{
		var object = JSON.parse(this.objectStore[uri].json);
		
		if (autoInstantiate)
		{
			object = this.instantiateModel_(object);
		}
		
		onSuccess(object);
		return;
	}
	else
	{
		throw new Error("unexpected URI: " + uri);
	}
	
	var foundRows = [];
	
	for (var i in this.objectStore)
	{
		var o = JSON.parse(this.objectStore[i].json);
		
		// views don't search design documents for some reason
		if (o._id.indexOf('_design/') != 0)
		{
			var emitted = selector(o);
			// Don't copy the result because CouchDB doesn't. If you
			// (or map()) modifies the emitted objects, then you can 
			// expect weird results.
			foundRows = foundRows.concat(emitted);
		}
	}
	
	onSuccess({total_rows: foundRows.length, offset: 0, rows: foundRows});
};

MockFreebase.prototype.save = function(object, onSuccess, onError)
{
	if (object._id && object._id.indexOf('_design/') == 0 && object.modelName)
	{
		this.app.models[object.modelName] = com.qwirx.freebase.Model(
			object.modelName, this, object.columns);
	}
	
	if (!object._id)
	{
		object._id = "mock_" + Math.random().toString().substring(2);
	}
	
	if (this.objectStore[object._id])
	{
		var oldRev = this.objectStore[object._id].revision;
		if (oldRev != object._rev)
		{
			throw new ConflictException(object, oldRev, object._rev);
		}
	}
	
	object._rev = Math.random().toString().substring(2);
	
	this.objectStore[object._id] = {
		revision: object._rev,
		json: JSON.stringify(goog.object.clone(object))
	};
	
	// com.qwirx.freebase.FunctionStringifier);
	this.dispatchEvent(new DocumentSaved(object));
	onSuccess(object);
};

MockFreebase.prototype.create$ = function(object, onSuccess, onError)
{
	if (object._id && this.objectStore[object._id])
	{
		onError(this, document, new Error("Failed to create document: " +
			"already exists: " + object._id));
	}
	else
	{
		this.save(object, onSuccess, onError);
	}
}

MockFreebase.prototype.attachEvent = function()
{
	// appears to be required by events.js line 232, but is
	// undocumented, and I don't think we need it anyway.
}

var mockFreebase;
var mockDocument = goog.dom.createDom(goog.dom.TagName.DIV,
	{'style': 'background-color: #eee; width: 50%; float: right;'});
goog.dom.appendChild(document.body, mockDocument);

function setUp()
{
	mockFreebase = new MockFreebase();
}

/**
 * Pass a block of code that takes a callback function c as its only
 * parameter, and passes that to the async method. If c is not called,
 * the assertion fails. Note that it assumes that the async method
 * will call the callback synchronously, in the same thread, e.g.
 * because it has been mocked to do so! So it's not a fully async test.
 */
function assertCallback(f)
{
	var calledBack = false;
	var result;
	
	function c()
	{
		calledBack = true;
		result = arguments;
	}
	
	f(c);
	
	assertTrue(calledBack);
	return result;
}

function testMockFreebaseApi()
{
	var foo = {_id: 'foo', name: 'Foo'};
	var bar = {name: 'Bar'};
	var baz = {name: 'Basil'};
	var jobs = {
		_id: '_design/Jobs',
		views: {
			all:  {map: function(o) { emit(o._id, o); }.toString()},
			name: {map: function(o) { emit(o.name, o); }.toString()},
			foo:  {map: function(o) { if (o.name == 'Foo') { emit(null, o); } }.toString()},
			bar:  {map: function(o) { if (o.name == 'Bar') { emit(o._id, null); } }.toString()}
		}
	};
	
	assertCallback(function(c) { mockFreebase.create$(foo, c); });
	assertThrows('Database should reject saving a second copy ' +
		'of the document', function()
		{
			mockFreebase.create$(foo, function(){});
		});

	assertCallback(function(c) { mockFreebase.create$(bar, c); })[0];
	assertCallback(function(c) { mockFreebase.create$(baz, c); })[0];
	assertObjectEquals("Should not be any app models at this point", {},
		mockFreebase.app.models);
	assertCallback(function(c) { mockFreebase.create$(jobs, c); });
	assertObjectEquals("Should still be no models (jobs is not really a model)",
		{}, mockFreebase.app.models);
	assertObjectEquals(foo, 
		assertCallback(function(c) { mockFreebase.get(foo._id, c) })[0]);
	
	// returns all three objects, because jobs.views.map.all doesn't discriminate
	assertObjectEquals([foo, bar, baz], 
		assertCallback(function(c) { mockFreebase.findAll('Jobs', c); })[0]);
	
	assertObjectEquals({
		total_rows: 3, offset: 0, rows: [
			{id: foo._id, key: foo._id, value: foo},
			{id: bar._id, key: bar._id, value: bar},
			{id: baz._id, key: baz._id, value: baz}
		]},
		assertCallback(function(c) { mockFreebase.view(jobs._id, 'all', c); })[0]);
	assertObjectEquals({
		total_rows: 3, offset: 0, rows: [
			{id: foo._id, key: foo.name, value: foo},
			{id: bar._id, key: bar.name, value: bar},
			{id: baz._id, key: baz.name, value: baz}
		]},
		assertCallback(function(c) { mockFreebase.view(jobs._id, 'name', c); })[0]);
	assertObjectEquals({
		total_rows: 1, offset: 0, rows: [
			{id: foo._id, key: null, value: foo},
		]},
		assertCallback(function(c) { mockFreebase.view(jobs._id, 'foo', c); })[0]);
	assertObjectEquals({
		total_rows: 1, offset: 0, rows: [
			{/* no ID without an object */ key: bar._id, value: null},
		]},
		assertCallback(function(c) { mockFreebase.view(jobs._id, 'bar', c); })[0]);
}

function testModelBuilder()
{
	var name = 'Foobar';
	var cols = [{name: "foo", type: 'String'},
		{name: "bar", type: 'Number'}];
	
	var Foobar = Model(name, mockFreebase, cols);
	assertEquals(mockFreebase, Foobar.freebase);
	assertEquals(name, Foobar.modelName);
	assertObjectEquals(com.qwirx.freebase.ModelClass.findAll,
		Foobar.findAll);

	var results;
	function collectResults(r)
	{
		results = r;
	};
	
	// must save the model before calling findAll
	mockFreebase.create$(Foobar.toDocument(), function(){});
	Foobar.findAll({}, collectResults);
	assertObjectEquals([], results);
	
	var frob = new Foobar();
	assertEquals(undefined, frob._id);
	Foobar.findAll({}, collectResults);
	assertObjectEquals([], results);

	mockFreebase.save(frob, function(){});
	assertNotNull(frob._id);
	assertEquals("Foobar", frob[Freebase.TABLE_FIELD]);
	assertEquals("toDocument should not be saved in the model object",
		undefined, frob.toDocument().toDocument);
	
	mockFreebase.findAll(Foobar.modelName, collectResults);
	assertObjectEquals("Database findAll method should instantiate each " +
		"result as a Model object", [frob], results);

	Foobar.findAll({}, collectResults);
	assertObjectEquals("Model findAll method should instantiate each " +
		"result as a Model object", [frob], results);

	var e = assertThrows('Database should reject saving a second copy ' +
		'of the model document', function()
		{
			mockFreebase.create$(Model(name, mockFreebase, cols).toDocument(),
				function(){});
		});
	
	/*
	Foobar.findFirst({}, collectResults);
	assertObjectEquals(frob, results);
	*/
}

function assertMessage(optional_comment, internal_details)
{
	if (optional_comment)
	{
		return optional_comment + " (" + internal_details + ")";
	}
	else
	{
		return internal_details;
	}
}

function assertTreeContents(tree, freebase, optional_comment)
{
	var ids = goog.object.getKeys(freebase.objectStore).sort();
	var len = ids.length;
	var objects = freebase.objectStore;
	var node;
	
	for (var i = 0; i < len; i++)
	{
		var id = ids[i];
		var object = objects[id];
		var node = tree.getChildAt(i);
		assertNotNull(assertMessage(optional_comment,
			"Item with ID " + id + " (index " + i + ") " +
			"missing from tree"), node);
		assertEquals(assertMessage(optional_comment,
			"Wrong label or different item in tree at index " + i),
			id, node.getText());
	}
	
	if (tree.hasChildren())
	{
		assertObjectEquals(assertMessage(optional_comment,
			"Unexpected children in tree from number " + len),
			[], tree.children_.slice(len));
	}
}

function testFreebaseGuiRun()
{
	var gui = new Freebase.Gui(mockFreebase);
	gui.run(mockDocument);
	
	var i = new goog.dom.NodeIterator(mockDocument);
	assertEquals(mockDocument, i.next());
	assertEquals(gui.splitter_.getElement(), i.next());
	assertEquals(goog.ui.SplitPane.FIRST_CONTAINER_CLASS_NAME_,
		i.next().className);
	assertEquals(gui.navigator_.getElement(), i.next());
	i.skipTag();
	assertEquals(goog.ui.SplitPane.SECOND_CONTAINER_CLASS_NAME_,
		i.next().className);
	assertEquals(gui.editArea_.getElement(), i.next());
	i.skipTag();
	var e = assertThrows(i.next);
	assertEquals(goog.iter.StopIteration, e);
	
	assertEquals(goog.ui.tree.TreeControl, gui.navigator_.constructor);
	assertTrue(gui.navigator_ instanceof goog.ui.tree.TreeControl);	
	assertTreeContents(gui.navigator_, mockFreebase, "Tree should " +
		"have been initialised at construction to show the initial " +
		"database contents");
	
	var Cat = Model('Cat', mockFreebase, [{name: 'name', type: 'String'},
		{name: 'age', type: 'Number'}]);
	assertObjectEquals({}, mockFreebase.objectStore);

	var catDoc = Cat.toDocument();
	mockFreebase.create$(catDoc, function(){});
	assertObjectEquals('The Model Document should have been saved in the database',
		JSON.stringify(catDoc), mockFreebase.objectStore[catDoc._id].json);
	assertObjectEquals('The reconstructed Model class should be ' +
		'identical to the one that produced the Model Document',
		Cat, mockFreebase.app.models.Cat);
	Cat = mockFreebase.app.models.Cat;
	assertTreeContents(gui.navigator_, mockFreebase, "Tree should have " +
		"been updated with the new model document");
		
	Badger = Model('Badger', mockFreebase, [{name: 'name', type: 'String'},
		{name: 'set', type: 'Object'}]);
	mockFreebase.create$(Badger.toDocument(), function(){});
	assertNotNull('Badger should be in the database after saving it',
		mockFreebase.objectStore[Badger.toDocument()._id]);
	assertTreeContents(gui.navigator_, mockFreebase, "Tree should have " +
		"been updated with nodes in sort order");

	mockFreebase.save(catDoc, function(){});
	assertTreeContents(gui.navigator_, mockFreebase,
		'Save should not create a duplicate tree node');
	
	var catNode = gui.navigator_.getChildAt(1);
	assertEquals(Cat.getId(), catNode.getModel().id);
	assertObjectEquals({}, gui.openDocumentsById_);
	catNode.select();
	var editor = gui.openDocumentsById_[Cat.getId()];
	assertNotNull(editor);
	assertTrue(goog.style.isElementShown(editor.editorControl_));
	editor.close();
	assertObjectEquals({}, gui.openDocumentsById_);
	assertFalse('Editor grid should have been removed from the ' +
		'editor container on close',
		goog.dom.contains(gui.getEditorContainer(), editor.editorControl_));

	// open the badger document by selecting it from the tree	
	var badgerNode = gui.navigator_.getChildAt(0);
	assertEquals(Badger.getId(), badgerNode.getModel().id);
	badgerNode.select();
	var badgerEditor = gui.openDocumentsById_[Badger.getId()];
	assertEquals(badgerEditor.tab_, gui.editAreaDocTabs_.getSelectedTab());
	assertTrue(goog.style.isElementShown(badgerEditor.editorControl_));

	// open the cat document by selecting it from the tree, check that
	// the badger tab is no longer active and the document is hidden
	catNode.select();
	var catEditor = gui.openDocumentsById_[Cat.getId()];
	assertEquals(catEditor.tab_, gui.editAreaDocTabs_.getSelectedTab());
	assertEquals(Cat.getId(), catNode.getModel().id);
	assertFalse(goog.style.isElementShown(badgerEditor.editorControl_));
	assertTrue(goog.style.isElementShown(catEditor.editorControl_));
	
	// switch docs by opening badger again
	badgerNode.select();
	assertEquals(badgerEditor.tab_, gui.editAreaDocTabs_.getSelectedTab());
	assertTrue(goog.style.isElementShown(badgerEditor.editorControl_));
	assertFalse(goog.style.isElementShown(catEditor.editorControl_));
	
	badgerEditor.close(); // close inactive tab
	catEditor.close(); // close active tab
	assertObjectEquals({}, gui.openDocumentsById_);
	
	// open the Cat document, showing a list of Cats
	var editor = assertCallback(function(c)
		{ gui.openDocument(Cat.getId(), c); })[0];
	
	// create a few cats
	old = new Cat({name: "Old Deuteronomy", age: 82});
	mockFreebase.save(old, function(){});
	etc = new Cat({name: "Etcetera", age: 0});
	mockFreebase.save(etc, function(){});
	
	// should have been added to the tree automatically, sorted by ID
	if (etc._id < old._id)
	{
		assertEquals(etc._id, gui.navigator_.getChildAt(2).getModel().id);
		assertEquals(old._id, gui.navigator_.getChildAt(3).getModel().id);
	}
	else
	{
		assertEquals(etc._id, gui.navigator_.getChildAt(3).getModel().id);
		assertEquals(old._id, gui.navigator_.getChildAt(2).getModel().id);
	}
			
	// data grid should have been updated
	var grid = editor.getDataGrid();
	assertEquals(2, grid.getRowCount());

	function assertGridRow(modelObject)
	{
		var row = grid.getRow(editor.getDocumentRowIndex(modelObject._id));
		assertEquals(modelObject._id,  row[0].value);
		assertEquals(modelObject.name, row[1].value);
		assertEquals("" + modelObject.age, row[2].value);
	}
	
	assertGridRow(etc);
	assertGridRow(old);
	
	// happy birthday Etcetera! Who knows?
	etc.age = 1;
	mockFreebase.save(etc, function(){});
	assertGridRow(etc);
	
	// close and reopen the Cat editor, check that it works when
	// documents already exist at open time
	editor.close();
	editor = assertCallback(function(c)	
		{ gui.openDocument(Cat.getId(), c); })[0];
	grid = editor.getDataGrid();
	assertGridRow(etc);
	assertGridRow(old);
	
	// try opening a document
	editor.close();
	editor = assertCallback(function(c) { gui.openDocument(etc._id, c); })[0];
	assertEquals('fb-edit-area-doc-div fb-docedit-autoform',
		editor.editorControl_.className);
	var flash = editor.autoFormFlash_;
	assertFalse(flash.isVisible());
	var table = editor.autoFormTable_;
	assertEquals('fb-doc-auto', table.className);
	var rows = goog.dom.getChildren(table);
	assertEquals('_id',  goog.dom.getNodeAtOffset(rows[0], 1).data);
	assertEquals('_rev', goog.dom.getNodeAtOffset(rows[1], 1).data);
	assertEquals('age',  goog.dom.getNodeAtOffset(rows[2], 1).data);
	assertEquals('name', goog.dom.getNodeAtOffset(rows[3], 1).data);
	assertEquals(4, rows.length);
	
	// change document using the form, check that it's saved
	var controls = editor.autoFormControls_;
	controls.age.value = 2;
	controls.name.value = 'Anonymouse';
	editor.submitButton_.performActionInternal(); // trigger a click event
	assertEquals('Document saved.', editor.autoFormFlash_.getContent());
	assertTrue(editor.autoFormFlash_.isVisible());
	
	var etc2 = assertCallback(function(c) { mockFreebase.get(etc._id, c); })[0];
	assertEquals(2, etc2.age);
	assertEquals('Anonymouse', etc2.name);
	assertFalse(etc2._rev == etc._rev);
	assertEquals(etc2._rev, editor.autoFormControls_._rev.value);
	assertEquals(etc2._rev, goog.dom.getChildren(rows[1])[1].innerHTML);

	// modify again to check that the revision in the form was updated
	// properly
	controls.age.value = 3;
	controls.name.value = 'Sylvester';
	editor.submitButton_.performActionInternal(); // trigger a click event
	assertEquals('Document saved.', editor.autoFormFlash_.getContent());
	assertTrue(editor.autoFormFlash_.isVisible());
	
	etc2 = assertCallback(function(c) { mockFreebase.get(etc._id, c); })[0];
	assertEquals(3, etc2.age);
	assertEquals('Sylvester', etc2.name);
	assertFalse(etc2._rev == etc._rev);
	assertEquals(etc2._rev, editor.autoFormControls_._rev.value);
	assertEquals(etc2._rev, goog.dom.getChildren(rows[1])[1].innerHTML);
}

</script>
</body>
</html>
